setwd("C:/Users/David/Desktop/Research/GitHub/EM/Real Data/Lung Cancer Cell Line")
source("C:/Users/David/Desktop/Research/GitHub/EM/non-simulation EM.R")
library("data.table")
library("stats")
library("DESeq2")
anno<-read.table("NSCLC_anno.txt",sep="\t",header=TRUE)
dat<-read.table("NSCLC_rsem.genes.exp.count.unnormalized.txt",sep="\t",header=TRUE)
row_names<-toupper(dat[,1])
dat<-round(dat[,-1],digits=0)
cts<-as.matrix(dat)
rownames(cts)<-row_names
colnames(cts)<-toupper(colnames(cts))
coldata<-anno[,-1]
rownames(coldata)<-toupper(anno[,1])
coldata<-coldata[,c("Adeno.Squamous","Tumor.location")]
all(rownames(coldata) %in% colnames(cts))
all(rownames(coldata) == colnames(cts))
dds<-DESeqDataSetFromMatrix(countData = cts,
colData = coldata,
design = ~ 1)
DESeq_dds<-DESeq(dds)
size_factors<-sizeFactors(DESeq_dds)
norm_y<-counts(DESeq_dds,normalized=TRUE)
dat<-read.table("NSCLC_rsem.genes.exp.count.unnormalized.txt",sep="\t",header=TRUE)
y<-round(dat[,-1],digits=0)
rownames(y)<-dat[,1]
y<-y[(rowSums(y)>=100),]
med_abs_dev<-rep(0,times=nrow(y))
for(j in 1:nrow(y)){
med_abs_dev[j]<-mad(as.numeric(y[j,]),constant=1)
}
y<-cbind(rownames(y),y,med_abs_dev)
subs_y<-as.data.table(y)[order(-med_abs_dev),head(.SD,100)]
genes_y<-subs_y[,1]
subs_y<-subs_y[,-1]
subs_y<-as.data.frame(subs_y[,-24])
k=2
lambda1=1
lambda2=1
tau=0.5
n<-ncol(y)
g<-nrow(y)
vect_y<-as.vector(t(y))
new_y<-rep(vect_y,each=k) # flatten and multiply each count by number of clusters
new_size_factors<-rep(rep(size_factors,each=k),times=g)    ############## corresponding size factors for each entry in trans. data #
gene<-rep(1:g,each=k*n) # gene for each corresponding new_y
clusts<-matrix(rep(diag(k),times=n*g),byrow=TRUE,ncol=k) # cluster indicators
d<-as.dist(1-cor(norm_y, method="spearman"))  ##Spearman correlation distance w/ log transform##
model<-hclust(d,method="complete")       # hierarchical clustering
cls<-cutree(model,k=k)
wts<-matrix(rep(0,times=k*ncol(y)),nrow=k)
for(c in 1:k){
wts[c,]=(cls==c)^2
}
vect_wts<-rep(as.vector(wts),times=g)
n<-ncol(y)
g<-nrow(y)
vect_y<-as.vector(t(y))
new_y<-rep(vect_y,each=k) # flatten and multiply each count by number of clusters
new_size_factors<-rep(rep(size_factors,each=k),times=g)    ############## corresponding size factors for each entry in trans. data #
gene<-rep(1:g,each=k*n) # gene for each corresponding new_y
clusts<-matrix(rep(diag(k),times=n*g),byrow=TRUE,ncol=k) # cluster indicators
d<-as.dist(1-cor(norm_y, method="spearman"))  ##Spearman correlation distance w/ log transform##
model<-hclust(d,method="complete")       # hierarchical clustering
cls<-cutree(model,k=k)
wts<-matrix(rep(0,times=k*ncol(y)),nrow=k)
for(c in 1:k){
wts[c,]=(cls==c)^2
}
wts
cls
k
for(c in 1:k){
wts[c,]=(cls==c)^2
}
cls
wts[1,]
wts
cls
cls==c
(cls==c)^2
wts[1,]
y<-subs_y
n<-ncol(y)
g<-nrow(y)
vect_y<-as.vector(t(y))
new_y<-rep(vect_y,each=k) # flatten and multiply each count by number of clusters
new_size_factors<-rep(rep(size_factors,each=k),times=g)    ############## corresponding size factors for each entry in trans. data #
gene<-rep(1:g,each=k*n) # gene for each corresponding new_y
clusts<-matrix(rep(diag(k),times=n*g),byrow=TRUE,ncol=k) # cluster indicators
d<-as.dist(1-cor(norm_y, method="spearman"))  ##Spearman correlation distance w/ log transform##
model<-hclust(d,method="complete")       # hierarchical clustering
cls<-cutree(model,k=k)
wts<-matrix(rep(0,times=k*ncol(y)),nrow=k)
for(c in 1:k){
wts[c,]=(cls==c)^2
}
vect_wts<-rep(as.vector(wts),times=g)
clust_index<-rep((1:k),times=n*g)
dat<-cbind(new_y,clusts,clust_index,gene,vect_wts,new_size_factors) # this is k*g*n rows. cols: count, indicator for cl1, cl2, cl3, genes, wts
colnames(dat)[1]<-c("count")
colnames(dat)[(k+2):ncol(dat)]<-c("clusts","g","weights","size_factors")
finalwts<-matrix(rep(0,times=k*ncol(y)),nrow=k)
maxit = 100
coefs<-matrix(rep(0,times=g*k),nrow=g)
pi<-rep(0,times=k)
Q<-rep(0,times=maxit)
theta_list<-list()       # temporary to hold all K x K theta matrices
a=1
dat[,"weights"]<-rep(as.vector(wts),times=g) # update weights column in dat
maxit_IRLS=100
for(j in 1:g){
if(a>1) {beta<-coefs[j,]} else {beta<-rep(log(mean(as.numeric(y[j,]))),times=k)}   # initialization of beta = gene mean
temp<-matrix(rep(0,times=maxit_IRLS*k),nrow=maxit_IRLS)    # to test for convergence of IRLS
dat_g<-dat[dat[,"g"]==j,]                                  # subset just the j'th gene
# USING GLM #
# for(c in 1:k){
#   fit<-glm(dat_g[,1]~dat_g[,2:4]-1,weights=dat_g[,ncol(dat_g)])
#   coefs[j,c]<-log(fit$coefficients[c])
# }
if(a==1){
theta<-matrix(rep(0,times=k^2),nrow=k)
for(c in 1:k){
for(cc in 1:k){
if(theta[c,cc]>=tau){theta[c,cc]<-beta[c]-beta[cc]}             # gTLP from Pan paper
else{theta[c,cc]<-soft_thresholding(beta[c]-beta[cc],lambda2)   #
}
}
}}else{
theta<-theta_list[[j]]
}                                       #initializing theta as either first estimate, or previous iteration value of thetas
for(i in 1:maxit_IRLS){
temp[i,]<-beta
if(a==1 & i==1){
eta<-matrix(rep(beta,times=n),nrow=n,byrow=TRUE)               # first initialization of eta
mu<-exp(eta)
}else if(i==1){
eta<-matrix(rep(beta,times=n),nrow=n,byrow=TRUE)+log(size_factors)     # initialization of eta for IRLS (prev. beta + offset)
mu<-exp(eta)
}
for(c in 1:k){
dat_gc<-dat_g[dat_g[,"clusts"]==c,]
W<-diag(mu[,c])
trans_y<-rep(0,times=n)
trans_y<-eta[,c] + dat_gc[,"weights"]*(dat_gc[,"count"]-mu[,c])/mu[,c] - log(dat_gc[,"size_factors"])    # subtract size factor from transf. y
#X<-dat_gc[,c+1]                                                  # no penalty
#eta_update<-ginv(t(X) %*% W %*% X) %*% t(X) %*% W %*% trans_y    # no penalty
beta[c]<-((lambda1*(sum(beta)-beta[c]+sum(theta[c,])-theta[c,c]))+((1/n)*sum(exp(beta[c])*trans_y)))/((lambda1*(k-1))+exp(beta[c]))
eta[,c]<-beta[c] + log(dat_gc[,"size_factors"])      # add back size factors to eta
mu[,c]<-exp(eta[,c])
}
# update on theta
for(c in 1:k){
for(cc in 1:k){
if(theta[c,cc]>=tau){theta[c,cc]<-beta[c]-beta[cc]}                      # gTLP from Pan paper
else{theta[c,cc]<-soft_thresholding(beta[c]-beta[cc],lambda2)}   #
}
}
# break condition for IRLS
if(i>1){
if(sum((temp[i,]-temp[i-1,])^2)<1E-7){
coefs[j,]<-beta
theta_list[[j]]<-theta
break
}
}
if(i==maxit_IRLS){
coefs[j,]<-beta
theta_list[[j]]<-theta
}
}
}
for(c in 1:k){
pi[c]=mean(wts[c,])
if(pi[c]<1E-6){
warning(paste("cluster proportion", c, "close to 0"))
pi[c]=1E-6
} # lowerbound for pi
if(pi[c]>(1-1E-6)){
warning(paste("cluster proportion", c, "close to 1"))
pi[c]=(1-1E-6)
} # upperbound for pi
}
l<-matrix(rep(0,times=k*n),nrow=k)
for(i in 1:n){
for(c in 1:k){
l[c,i]<-sum(dpois(y[,i],lambda=exp(coefs[,c]),log=TRUE))    # posterior log like, include size_factor of subj
}
}
pt1<-(log(pi)%*%rowSums(wts))
pt2<-sum(wts*l)
Q[a]<-pt1+pt2
if(a>10){if(abs(Q[a]-Q[a-10])<1E-5) {
finalwts<-wts
break
}}
logdenom = apply(log(pi) + l, 2,logsumexpc)
for(c in 1:k){
wts[c,]<-exp(log(pi[c])+l[c,]-logdenom)
}
a=2
dat[,"weights"]<-rep(as.vector(wts),times=g) # update weights column in dat
maxit_IRLS=100
View(dat)
wts
j=1
if(a>1) {beta<-coefs[j,]} else {beta<-rep(log(mean(as.numeric(y[j,]))),times=k)}   # initialization of beta = gene mean
temp<-matrix(rep(0,times=maxit_IRLS*k),nrow=maxit_IRLS)    # to test for convergence of IRLS
dat_g<-dat[dat[,"g"]==j,]                                  # subset just the j'th gene
View(dat_g)
size_factors
subs_y[1,]
if(a==1){
theta<-matrix(rep(0,times=k^2),nrow=k)
for(c in 1:k){
for(cc in 1:k){
if(theta[c,cc]>=tau){theta[c,cc]<-beta[c]-beta[cc]}             # gTLP from Pan paper
else{theta[c,cc]<-soft_thresholding(beta[c]-beta[cc],lambda2)   #
}
}
}}else{
theta<-theta_list[[j]]
}                                       #initializing theta as either first estimate, or previous iteration value of thetas
theta
theta_list[[1]]
i=1
temp[i,]<-beta
if(a==1 & i==1){
eta<-matrix(rep(beta,times=n),nrow=n,byrow=TRUE)               # first initialization of eta
mu<-exp(eta)
}else if(i==1){
eta<-matrix(rep(beta,times=n),nrow=n,byrow=TRUE)+log(size_factors)     # initialization of eta for IRLS (prev. beta + offset)
mu<-exp(eta)
}
eta
beta
c=1
dat_gc<-dat_g[dat_g[,"clusts"]==c,]
View(dat_gc)
wts
size_factors
