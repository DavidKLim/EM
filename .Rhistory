setwd("C:/Users/David/Desktop/Research/GitHub/EM")
source("EM.R")
library(MASS)
n=20
g=200
k=3
pi=c(.5,.3,.2)
sigma=diag(k)
b=matrix(rep(0,times=k*g),nrow=g,byrow=TRUE) # initialize betas
set.seed(1)
b[1:200,]<-mvrnorm(200,mu=c(3,3.5,4),sigma) # betas with very distinct means
b[1:200,]<-mvrnorm(200,mu=c(3,3.5,4),sigma) # betas with very distinct means
b[1:200,]<-mvrnorm(200,mu=c(3,3.5,4),sigma) # betas with very distinct means
b[1:200,]<-mvrnorm(200,mu=c(3,3.5,4),sigma) # betas with very distinct means
setwd("C:/Users/David/Desktop/Research/GitHub/EM")
source("EM.R")
library(MASS)
set.seed(24)
n=20
k=3
g=200
pi=c(1/3,1/3,1/3)
sigma=diag(k)
b=matrix(rep(0,times=k*g),nrow=g,byrow=TRUE) # initialize betas
b[1:100,]<-mvrnorm(100,mu=c(1,2,3),sigma)
max_alpha=1
max_lambda1=1
max_lambda2=0.05
b[101:200,]<-mvrnorm(100,mu=c(2,2,2),sigma) # 50% nondiscriminatory
X<-EM(n=n,k=k,g=g,init_pi=pi,b=b,alpha=max_alpha,lambda1=max_lambda1,lambda2=max_lambda2)
View(X$coefs)
mean(X$coefs[1:100,1])
mean(X$coefs[1:100,2])
mean(X$coefs[1:100,3])
mean(X$coefs[101:200,3])
mean(X$coefs[101:200,2])
mean(X$coefs[101:200,1])
X$pi
mean(X$nondiscriminatory)
X$nondiscriminatory
sim=10
for(i in 1:sim){
X<-EM(n=n,k=k,g=g,init_pi=pi,b=b,alpha=max_alpha,lambda1=max_lambda1,lambda2=max_lambda2)
temp_pi[i,]<-X$pi
temp_coefs[[i]]<-X$coefs
ARI[i]<-X$ARI
num_nondiscr[i]<-X$nondiscriminatory
}
mean_pi<-colSums(t(apply(temp_pi,1,sort)))/sim # sort in increasing order, then mean #
mean_pi<-mean_pi[order(mean_pi)][rank(pi)] # order of true pi
sorted_coefs<-list()
for(i in 1:sim){
sorted_coefs[[i]]<-temp_coefs[[i]][,order(temp_pi[i,])] # sort by increasing order of pi (to align --> take mean) #
}   # trickier when varying each gene mean
mean_coefs<-Reduce('+',sorted_coefs)/sim # gxk matrix of mean coef's across simulations #
sorted_means<-matrix(rep(0,times=g*k),nrow=g)
for(j in 1:g){
sorted_means[j,]<-mean_coefs[j,rank(pi)] # order each row according to order of true pi #
}
coef1_means<-colSums(sorted_means[1:100,])/nrow(sorted_means[1:100,])
coef2_means<-colSums(sorted_means[101:200,])/nrow(sorted_means[101:200,])
mean_ARI<-mean(ARI)
SSE_estims<-sum((pi-mean_pi)^2)+sum((b-sorted_means)^2)
sim=100
temp_pi<-matrix(rep(0,times=k*sim),nrow=sim)
temp_coefs<-list()
ARI<-rep(0,times=sim)
sim=10
for(i in 1:sim){
X<-EM(n=n,k=k,g=g,init_pi=pi,b=b,alpha=max_alpha,lambda1=max_lambda1,lambda2=max_lambda2)
temp_pi[i,]<-X$pi
temp_coefs[[i]]<-X$coefs
ARI[i]<-X$ARI
num_nondiscr[i]<-X$nondiscriminatory
}
mean_pi<-colSums(t(apply(temp_pi,1,sort)))/sim # sort in increasing order, then mean #
mean_pi<-mean_pi[order(mean_pi)][rank(pi)] # order of true pi
sorted_coefs<-list()
for(i in 1:sim){
sorted_coefs[[i]]<-temp_coefs[[i]][,order(temp_pi[i,])] # sort by increasing order of pi (to align --> take mean) #
}   # trickier when varying each gene mean
mean_coefs<-Reduce('+',sorted_coefs)/sim # gxk matrix of mean coef's across simulations #
sorted_means<-matrix(rep(0,times=g*k),nrow=g)
for(j in 1:g){
sorted_means[j,]<-mean_coefs[j,rank(pi)] # order each row according to order of true pi #
}
coef1_means<-colSums(sorted_means[1:100,])/nrow(sorted_means[1:100,])
coef2_means<-colSums(sorted_means[101:200,])/nrow(sorted_means[101:200,])
mean_ARI<-mean(ARI)
SSE_estims<-sum((pi-mean_pi)^2)+sum((b-sorted_means)^2)
num_nondiscr<-rep(0,times=sim)
for(i in 1:sim){
X<-EM(n=n,k=k,g=g,init_pi=pi,b=b,alpha=max_alpha,lambda1=max_lambda1,lambda2=max_lambda2)
temp_pi[i,]<-X$pi
temp_coefs[[i]]<-X$coefs
ARI[i]<-X$ARI
num_nondiscr[i]<-X$nondiscriminatory
}
mean_pi<-colSums(t(apply(temp_pi,1,sort)))/sim # sort in increasing order, then mean #
mean_pi<-mean_pi[order(mean_pi)][rank(pi)] # order of true pi
sorted_coefs<-list()
for(i in 1:sim){
sorted_coefs[[i]]<-temp_coefs[[i]][,order(temp_pi[i,])] # sort by increasing order of pi (to align --> take mean) #
}   # trickier when varying each gene mean
mean_coefs<-Reduce('+',sorted_coefs)/sim # gxk matrix of mean coef's across simulations #
sorted_means<-matrix(rep(0,times=g*k),nrow=g)
for(j in 1:g){
sorted_means[j,]<-mean_coefs[j,rank(pi)] # order each row according to order of true pi #
}
coef1_means<-colSums(sorted_means[1:100,])/nrow(sorted_means[1:100,])
coef2_means<-colSums(sorted_means[101:200,])/nrow(sorted_means[101:200,])
mean_ARI<-mean(ARI)
SSE_estims<-sum((pi-mean_pi)^2)+sum((b-sorted_means)^2)
coef1_means
coef2_means
X$nondiscriminatory
sorted_Coefs
sorted_coefs
mean_coefs
mean(mean_coefs[1:100,1])
mean(mean_coefs[1:100,2])
mean(mean_coefs[1:100,3])
mean(mean_coefs[101:200,3])
mean(mean_coefs[101:200,2])
mean(mean_coefs[101:200,1])
mean(sorted_coefs[[1]][1:100,1]]
mean(sorted_coefs[[1]][1:100,1])
mean(sorted_coefs[[1]][1:100,2])
mean(sorted_coefs[[1]][1:100,3])
mean(sorted_coefs[[2]][1:100,3])
mean(sorted_coefs[[2]][1:100,2])
mean(sorted_coefs[[2]][1:100,1])
init_pi=pi
y<-matrix(rep(0,times=g*n),nrow=g)      # initialize count matrix gxn #
z = rmultinom(n,1,init_pi)
for(j in 1:g){
for(c in 1:k){
y[j,z[c,]==1] = rpois(sum(z[c,]==1), lambda = exp(b[j,c]))
}
}
vect_y<-as.vector(t(y))
new_y<-rep(vect_y,each=k) # flatten and multiply each count by number of clusters
gene<-rep(1:g,each=k*n) # gene for each corresponding new_y
clusts<-matrix(rep(diag(k),times=n*g),byrow=TRUE,ncol=k) # cluster indicators
d<-dist(t(y))
model<-hclust(d)
install.packages("SOfun")
library(SOfun)
source("http://news.mrdwab.com/install_github.R")
install_github("mrdwab/SOfun")
library(SOfun)
cls
cls<-cutree(model,k=k)
cls
allperms(cls)
install.packages("permutation")
install.packages("permute")
library(permute)
allPerms(cls)
allPerms(c(3,4,5))
allPerms(3)
cls2<-cls[cls]
cls
cls
cls2
all_perms=allPerms(1:k)
all_perms[1]
perm1<-all_perms[1,]
perm1
other_clusts=list()
for(ii in 1:nrow(all_perms)){
for(i in 1:n){
other_clusts[[ii]][i]<-perm1[cls[i]]
}
}
perm1[cls[1]]
perm1[cls[2]]
perm1[cls[3]]
cls
for(ii in 1:nrow(all_perms)){
for(i in 1:n){
other_clusts[[ii]][i]<-all_perms[ii,cls[i]]
}
}
other_clusts=list()
for(ii in 1:nrow(all_perms)){
for(i in 1:n){
other_clusts[[ii]][i]<-all_perms[ii,cls[i]]
}
}
otherclusts
other_clusts
ii
other_clusts[[1]][1]<-all_perms[1,cls[1]]
other_clusts[[1]][1]-1
other_clusts[[1]][1]<-1
other_clusts[[1]]<-c(1)
all_perms=allPerms(1:k)
other_clusts=list()
temp_clust<-c(0,times=n)
for(ii in 1:nrow(all_perms)){
for(i in 1:n){
temp_clust<-all_perms[ii,cls[i]]
}
other_clusts[[ii]]<-temp_clust
}
other_clusts
all_perms=allPerms(1:k)
other_clusts=list()
temp_clust<-c(0,times=n)
for(ii in 1:nrow(all_perms)){
for(i in 1:n){
temp_clust[i]<-all_perms[ii,cls[i]]
}
other_clusts[[ii]]<-temp_clust
}
other_clusts
cls
other_clusts[[nrow(all_perms)+1]]<-cls
for(ii in 1:nrow(all_perms)+1){
print(mean(cls==other_clusts[[ii]]))
}
for(ii in 1:(nrow(all_perms)+1)){
mean(cls==other_clusts[[ii]])
}
for(ii in 1:(nrow(all_perms)+1)){
print(mean(cls==other_clusts[[ii]]))
}
cls
other_clusts[[1]]
match_index<-rep(0,times=nrow(all_perms)+1)
match_index<-rep(0,times=nrow(all_perms)+1)
for(ii in 1:(nrow(all_perms)+1)){
match_index[ii]<-mean(cls==other_clusts[[ii]])
}
match_index
d<-dist(t(y))
model<-hclust(d)
cls<-cutree(model,k=k)
all_perms=allPerms(1:k)
all_clusts=list()
temp_clust<-rep(0,times=n)
for(ii in 1:nrow(all_perms)){
for(i in 1:n){
temp_clust[i]<-all_perms[ii,cls[i]]
}
all_clusts[[ii]]<-temp_clust
}
all_clusts[[nrow(all_perms)+1]]<-cls     # contains all permutations of cluster indices
match_index<-rep(0,times=nrow(all_perms)+1)
for(ii in 1:(nrow(all_perms)+1)){
match_index[ii]<-mean(cls==all_clusts[[ii]])
}
match_index
cls<-all_clusts
cls<-all_clusts[[which.max(match_index)]]
cls
which.max(match_index)
cls<-cutree(model,k=k)
cls
cls<-cutree(model,k=k)
cls
z
clusts
z
true_clusters<-rep(0,times=n)
for(i in 1:n){
true_clusters[i]<-which(z[,i]==1)
}
true_clusters
for(ii in 1:(nrow(all_perms)+1)){
match_index[ii]<-mean(true_clusters==all_clusts[[ii]])     # compares each permutation to true --> % of match
}
match_index
cls<-all_clusts[[which.max(match_index)]]
source("EM.R")
library(MASS)
set.seed(24)
n=20
k=3
g=200
pi=c(.5,.3,.2)
sigma=diag(k)
b=matrix(rep(0,times=k*g),nrow=g,byrow=TRUE) # initialize betas
b[1:200,]<-mvrnorm(200,mu=c(3,3.5,4),sigma) # betas with very distinct means
sim=10
temp_pi<-matrix(rep(0,times=k*sim),nrow=sim)
temp_coefs<-list()
ARI<-rep(0,times=sim)
max_alpha
num_nondiscr<-rep(0,times=sim)
for(i in 1:sim){
X<-EM(n=n,k=k,g=g,init_pi=pi,b=b,alpha=max_alpha,lambda1=max_lambda1,lambda2=max_lambda2)
temp_pi[i,]<-X$pi
temp_coefs[[i]]<-X$coefs
ARI[i]<-X$ARI
num_nondiscr[i]<-mean(X$nondiscriminatory)
}
source("EM.R")
library(MASS)
set.seed(24)
n=20
k=3
g=200
pi=c(1/3,1/3,1/3)
sigma=diag(k)
b=matrix(rep(0,times=k*g),nrow=g,byrow=TRUE) # initialize betas
b[1:100,]<-mvrnorm(100,mu=c(1,2,3),sigma)
b[101:200,]<-mvrnorm(100,mu=c(2,2,2),sigma) # 50% nondiscriminatory
sim=10
temp_pi<-matrix(rep(0,times=k*sim),nrow=sim)
temp_coefs<-list()
ARI<-rep(0,times=sim)
max_alpha=1
max_lambda1=1
max_lambda2=0.05
num_nondiscr<-rep(0,times=sim)
for(i in 1:sim){
X<-EM(n=n,k=k,g=g,init_pi=pi,b=b,alpha=max_alpha,lambda1=max_lambda1,lambda2=max_lambda2)
temp_pi[i,]<-X$pi
temp_coefs[[i]]<-X$coefs
ARI[i]<-X$ARI
num_nondiscr[i]<-mean(X$nondiscriminatory)
}
temp_pi
temp_coefs
mean(temp_coefs[1:100,1])
mean(temp_coefs[[1]][1:100,1])
mean(temp_coefs[[1]][1:100,2])
mean(temp_coefs[[1]][1:100,3])
mean(temp_coefs[[1]][101:200,3])
mean(temp_coefs[[1]][101:200,2])
mean(temp_coefs[[1]][101:200,1])
mean_pi<-colSums(temp_pi)/sim
mean_coefs<-Reduce('+',temp_coefs)/sim
coef1_means<-colSums(mean_coefs)/nrow(mean_coefs)
mean_pi
mean_coefs
coef1_means
coef1_means<-colSums(mean_coefs[1:100,])/100
coef2_means<-colSums(mean_coefs[101:200,])/100
coef1_means
coef2_means
exp(1)
exp(2)
exp(3)
